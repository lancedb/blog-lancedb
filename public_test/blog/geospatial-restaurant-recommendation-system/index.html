<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Geospatial Restaurant Recommendation System - LanceDB Blog</title><link rel=stylesheet href=/css/custom.css><link rel=stylesheet href=/css/syntax-highlighting.css><script src=/js/toc-progress.js></script><script src=/js/heading-links.js></script><script src=/js/announcement.js></script><script src=/js/code-blocks.js></script></head><body><div class=announcement-bar id=announcement-bar><div class=announcement-content><span>June 1st, 2025: LanceDB Cloud is now in public beta!</span>
<a href=https://lancedb.com/cloud class=announcement-link>Try it now â†’</a>
<button class=announcement-close onclick=closeAnnouncement()>Ã—</button></div></div><header class=site-header><div class=header-content><a href=/ class=site-title><img src=/assets/blog/logo.png alt="LanceDB Blog" class=site-logo></a><div class=header-links><a href=/docs class=header-link>Documentation</a>
<a href=/pricing class=header-link>Pricing</a>
<a href=/get-started class="header-link get-started">Get Started</a></div></div></header><div class=content-wrapper><div class=toc-container><div class=toc><h2>Table of Contents</h2><nav id=TableOfContents><ul><li><ul><li><a href=#how-to-start>How to start?</a></li><li><a href=#setting-up-vector-database>Setting up Vector Database</a></li><li><a href=#setting-up-the-geospatial-reference>Setting up the Geospatial Reference.</a></li><li><a href=#searching-like-a-pro>Searching like a pro</a></li><li><a href=#using-the-geospatial-data>Using the Geospatial data</a></li></ul></li></ul></nav></div></div><main><h1>Geospatial Restaurant Recommendation System</h1><div class=post-meta><span class=post-author>Vipul Maheshwari</span>
<span class=meta-divider>â€¢</span>
<span class=post-date>December 31, 2024</span></div><article class=single-post><img src=/assets/blog/geospatial-restaurant-recommendation-system/geospatial-restaurant-recommendation-system.png alt="Geospatial Restaurant Recommendation System" class=preview-image><div class=post-content><p>ðŸ’¡</p><p>This is a community blog by Vipul Maheshwari</p><p><img src=__GHOST_URL__/content/images/2024/12/image-10.png alt>
In 2024, I did spend significant amount of time playing with RAG and Vector Database. Typically, LanceDB was at the core and it was one amazing hell of a ride. As the year is ending, I tried to make a simple restaurant recommendation system but it&rsquo;s going to be slightly different. The idea is to use this <a href="https://www.kaggle.com/datasets/abhijitdahatonde/swiggy-restuarant-dataset?resource=download">Restaurant Dataset</a> to answer queries like &ldquo;Is there any cafe nearby that serves Punjabi food?&rdquo; or &ldquo;What are the top 5 restaurants in the city that serve Chinese food?&rdquo;.</p><p>The twist is, that we need some form of geospatial data to mold the data points into a form that can be used for queries that are related to the distance.
<img src=__GHOST_URL__/content/images/2024/12/Geospatial-Recommendation-System.png alt></p><h3 id=how-to-start>How to start?</h3><p>Well, the first thing is to sort out some relevant features that are required for the recommendation system. So generally, folks who are searching for any recommendation for a restaurant, are looking out for things like the restaurant&rsquo;s name, location, and what kind of food they serve, or other details like ratings or maybe how much time it takes for a restaurant to deliver the food or what&rsquo;s the average order prices. To follow along, here is the colab
[</p><p>Google Colab</p><p><img src=__GHOST_URL__/content/images/icon/favicon-19.ico alt></p><p><img src=__GHOST_URL__/content/images/thumbnail/colab_favicon_256px-19.png alt>
](<a href=https://colab.research.google.com/github/lancedb/vectordb-recipes/blob/main/examples/Geospatial-Recommendation-System/geospatial-recommendation.ipynb>https://colab.research.google.com/github/lancedb/vectordb-recipes/blob/main/examples/Geospatial-Recommendation-System/geospatial-recommendation.ipynb</a>)
So, we need to extract these features from the dataset.</p><pre><code>import pandas as pd

restaurant_data = pd.read_csv(&quot;data.csv&quot;)
restaurant_data = restaurant_data[restaurant_data.columns[1:]]
restaurant_data.dropna(inplace=True)
restaurant_data.drop_duplicates(inplace=True)
restaurant_data.head()
</code></pre><p><img src=__GHOST_URL__/content/images/2024/12/image-7.png alt>
To keep things simple, we&rsquo;re just going to focus on a few key details for now: the type of food a restaurant serves, how customers rate it on average, and where it&rsquo;s located. By sticking to these basics, we can quickly give people great recommendations without complicating things.</p><pre><code>data_points_vectors = []

for _, row in restaurant_data.iterrows():
    filter_cols = ['Food type', 'Avg ratings', 'Address']
    data_point = &quot;#&quot;.join(f&quot;{col}/{row[col]}&quot; for col in filter_cols)
    data_points_vectors.append(data_point)

# Add the new column to the DataFrame
restaurant_data[&quot;query_string&quot;] = data_points_vectors
</code></pre><p>You can see that I&rsquo;ve used <code>#</code> to separate different sections and <code>/</code> for splitting up the key-value pairs. Just a heads up, you can pick different separators and delimiters if you like, but since I&rsquo;m using FTS (full-text search) from LanceDB, a few are reserved for internal representations. If you need to, you can use a backslash as a prefix to support the reserved ones and still use them.</p><p>This is how a single query string looks :</p><pre><code>'Food type/Biryani,Chinese,North Indian,South Indian#Avg ratings/4.4#Address/5Th Block'
</code></pre><p>Ok, this looks good! Next, we need to turn our query string into a vector. You can choose any embedding model that fits your needs, but I&rsquo;ll be using the <code>paraphrase-MiniLM-L6-v2</code> model for now. Basically, all we have to do is encode our query strings into vectors and then load up the payload with the relevant information.</p><pre><code>from sentence_transformers import SentenceTransformer
model = SentenceTransformer('paraphrase-MiniLM-L6-v2')

list_of_payloads = []

for index, row in restaurant_data.iterrows():
    encoded_vector = model.encode(row['query_string'])
    payload = {
        'Area': row['Area'],
        'City': row['City'],
        'Restaurant': row['Restaurant'],
        'Price': row['Price'],
        'Avg_ratings': row['Avg ratings'],
        'Total_ratings': row['Total ratings'],
        'Food_type': row['Food type'],
        'Address': row['Address'],
        'Delivery_time': row['Delivery time'],
        'query_string': row['query_string'],
        'vector': encoded_vector
    }

    list_of_payloads.append(payload)
</code></pre><h3 id=setting-up-vector-database>Setting up Vector Database</h3><p>So, we&rsquo;ve got our <code>list_of_payloads</code> that includes all the relevant data we&rsquo;re going to store in our vector database. Let&rsquo;s get LanceDB set up here:</p><pre><code>import lancedb

# Connect to the LanceDB instance
uri = &quot;data&quot;
db = lancedb.connect(uri)

lancedb_table = db.create_table(&quot;restaurant-geocoding-app&quot;, data=list_of_payloads)
lancedb_df = lancedb_table.to_pandas()
lancedb_df.head()
</code></pre><p><img src=__GHOST_URL__/content/images/2024/12/image-8.png alt></p><h3 id=setting-up-the-geospatial-reference>Setting up the Geospatial Reference.</h3><p>Now that our vector database is ready, the next step is to convert user queries into our specific query format. Essentially, what we will do here is to carefully extract key details from each user query to form a structured dictionary. This structured data will then be reformatted to match the pattern of our query strings. To achieve this, I&rsquo;ll just use an LLM to decipher the user queries and identify the crucial entities we need.</p><pre><code>import os
from openai import OpenAI
from dotenv import load_dotenv

load_dotenv()

api_key = os.getenv(&quot;OPENAI_API_KEY&quot;)

# Initialize the OpenAI client
client = OpenAI(api_key=api_key)

query_string = &quot;Hi, I am looking for a casual dining restaurant where Indian or Italian food is served near the HSR Bangalore&quot;

# Helper prompt to extract structured data from ip_prompt
total_prompt = f&quot;&quot;&quot;Query String: {query_string}\n\n\
Now from the query string above extract these following entities pinpoints:
1. Food type : Extract the food type 
2. Avg ratings : Extract the average ratings
3. Address : Extract the current exact location, don't consider the fillers like &quot;near&quot; or &quot;nearby&quot;.

NOTE : For the Current location, try to understand the pin point location in the query string. Do not give any extra information. If you make the mistakes, bad things
will happen.

Finally return a python dictionary using those points as keys and don't write the markdown of python. If value of a key is not mentioned, then set it as None.
&quot;&quot;&quot;

# Make a request to OpenAI's API
completion = client.chat.completions.create(
    model=&quot;gpt-4o&quot;,  # Use the appropriate model
    store=True,
    messages=[
        {&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: total_prompt}
    ]
)

# Extract the generated text
content = completion.choices[0].message.content
print(content)

{
  &quot;Food type&quot;: &quot;Indian or Italian&quot;,
  &quot;Avg ratings&quot;: None,
  &quot;Address&quot;: &quot;HSR Bangalore&quot;
}
</code></pre><p>Now, all we need to do is process this output.</p><pre><code>import ast

# Convert the string content to a dictionary
try:
    response_dict = ast.literal_eval(content)
except (ValueError, SyntaxError) as e:
    print(&quot;Error parsing the response:&quot;, e)
    response_dict = {}


filter_cols = ['Food type', 'Avg ratings', 'Address']
query_string_parts = [f&quot;{col}/{response_dict.get(col)}&quot; for col in filter_cols if response_dict.get(col)]

query_string = &quot;#&quot;.join(query_string_parts)
print((query_string))
</code></pre><p>Well, now the user query looks like this:</p><pre><code>Food type/Indian or Italian#Address/HSR Bangalore
</code></pre><p>Well, this user query is now formatted exactly like our <code>query_strings</code>. We can go ahead and search through the vector database to find the top restaurants that best match this query.</p><h3 id=searching-like-a-pro>Searching like a pro</h3><p>I&rsquo;ll be using the Full Text Search (FTS) feature from LanceDB to run the search. It&rsquo;s basically a semantic search. You can read more about what&rsquo;s happening behind the scenes <a href=https://lancedb.github.io/lancedb/fts/#example>here</a>.</p><pre><code># Create the FTS index and search
lancedb_table.create_fts_index(&quot;query_string&quot;, replace=True)
results = lancedb_table.search(query_string).to_pandas()
results.head()
</code></pre><p><img src=__GHOST_URL__/content/images/2024/12/image-9.png alt></p><h3 id=using-the-geospatial-data>Using the Geospatial data</h3><p>So basically when someone searches for nearby restaurants, maybe they&rsquo;re craving a specific type of cuisine or looking for highly-rated places, we first search up the places that fills there requirements. Now after identifying potential options, we use the <a href=https://developers.google.com/maps/documentation/geocoding/overview>Geospatial API</a> to pinpoint their exact locations. The Google Maps API is perfect for thisâ€”it grabs the latitude and longitude so we know precisely where each restaurant is. With these coordinates, we can then easily figure out which places are closest to the user&rsquo;s place.</p><p>If you didn&rsquo;t get that, Bear with me, this is going to be super cool. So first thing we need to do is to set our Geospatial function which takes a place and returns the coordinates:</p><pre><code>import requests
import math

def get_google_geocoding(address, api_key):
    base_url = &quot;https://maps.googleapis.com/maps/api/geocode/json&quot;
    params = {&quot;address&quot;: address, &quot;key&quot;: api_key}
    response = requests.get(base_url, params=params)
    
    if response.status_code == 200:
        result = response.json()
        if result[&quot;status&quot;] == &quot;OK&quot;:
            latitude = result[&quot;results&quot;][0][&quot;geometry&quot;][&quot;location&quot;][&quot;lat&quot;]
            longitude = result[&quot;results&quot;][0][&quot;geometry&quot;][&quot;location&quot;][&quot;lng&quot;]
            return (latitude, longitude)
        else:
            print(f&quot;Google API: No results found for address: {address}&quot;)
            return None
    else:
        print(f&quot;Google API: Request failed for address: {address}&quot;)
        return None
</code></pre><p>For the distance calculation, there&rsquo;s this thing called the <code>Haversine formula</code>. It uses the coordinates of two points and basically draws an imaginary straight line between them across the earth to measure how far they are from each other. There&rsquo;s a bit of math involved in how this formula works, but we can skip that part for now. Here&rsquo;s what the formula looks like:</p><pre><code>def haversine(coord1, coord2):
    R = 6371.0  # Radius of the Earth in kilometers
    lat1, lon1 = map(math.radians, coord1)
    lat2, lon2 = map(math.radians, coord2)
    dlat = lat2 - lat1
    dlon = lon2 - lon1
    a = math.sin(dlat / 2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon / 2)**2
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
    distance = R * c
    return distance
</code></pre><p>Well, everything seems solid now, the only thing left is the current location. Here&rsquo;s what we can do: if a user asks about restaurants near a specific area like <code>nearby HSR layout</code> we can easily pull the current location from the postprocessing we did earlier. If not, for now, we can just input the current location manually. Then, we&rsquo;ll check how far our top-n restaurants are from our user&rsquo;s place.</p><p>Well let&rsquo;s see what we get:</p><pre><code>def process_top_restaurants(data, current_location, api_key, top_n=5):
    current_coords = get_google_geocoding(current_location, api_key)
    if not current_coords:
        return

    for index, row in data.head(top_n).iterrows():
        complete_address = f&quot;{row['Restaurant']}, {row['City']}&quot;
        restaurant_coords = get_google_geocoding(complete_address, api_key)
        if restaurant_coords:
            distance = haversine(current_coords, restaurant_coords)
            print(f&quot;Restaurant Name: {row['Restaurant']}&quot;)
            print(f&quot;Distance: {distance:.2f} km&quot;)
            print(f&quot;Area: {row['Area']}&quot;)
            print(f&quot;Price: {row['Price']}&quot;)
            print(f&quot;Coordinates: {restaurant_coords}&quot;)
            print(f&quot;Cuisines Type: {row['Food_type']}&quot;)
            print(&quot;-&quot; * 40)

# Example usage
api_key = os.getenv('GOOGLE_MAPS_API')
current_location = 'HSR Layout, Bangalore'
process_top_restaurants(results, current_location, api_key, top_n=3)

Restaurant Name: Brooks And Bonds Brewery
Distance: 3.36 km
Area: Koramangala
Price: 200.0
Coordinates: (12.9341801, 77.62334249999999)
Cuisines Type: Indian
----------------------------------------
Restaurant Name: Cafe Azzure
Distance: 8.06 km
Area: Ashok Nagar
Price: 1000.0
Coordinates: (12.975012, 77.6076558)
Cuisines Type: American,Italian
----------------------------------------
Restaurant Name: Tottos Pizza
Distance: 7.92 km
Area: Central Bangalore
Price: 500.0
Coordinates: (12.9731935, 77.607012)
Cuisines Type: Continental,Italian
----------------------------------------
</code></pre><p>Here we go&mldr; This is cool :)</p></div></article><div class=author-section><img src=/assets/authors/default-avatar.png alt="Vipul Maheshwari" class=author-avatar><div class=author-info><h3 class=author-name>Vipul Maheshwari</h3><div class=author-social></div></div></div><div class=related-posts><h2>Related Posts</h2><div class=related-posts-grid><article class=related-post><a href=/blog/columnar-file-readers-in-depth-repetition-definition-levels/><img src=/assets/blog/columnar-file-readers-in-depth-repetition-definition-levels/columnar-file-readers-in-depth-repetition-definition-levels.png alt="Columnar File Readers in Depth: Repetition & Definition Levels" class=related-preview-image></a><h3><a href=/blog/columnar-file-readers-in-depth-repetition-definition-levels/>Columnar File Readers in Depth: Repetition & Definition Levels</a></h3><div class=post-meta><span class=post-author>Weston Pace</span>
<span class=post-date>June 2, 2025</span></div></article><article class=related-post><a href=/blog/columnar-file-readers-in-depth-column-shredding/><img src=/assets/blog/columnar-file-readers-in-depth-column-shredding/columnar-file-readers-in-depth-column-shredding.png alt="Columnar File Readers in Depth: Column Shredding" class=related-preview-image></a><h3><a href=/blog/columnar-file-readers-in-depth-column-shredding/>Columnar File Readers in Depth: Column Shredding</a></h3><div class=post-meta><span class=post-author>Weston Pace</span>
<span class=post-date>May 15, 2025</span></div></article><article class=related-post><a href=/blog/columnar-file-readers-in-depth-compression-transparency/><img src=/assets/blog/columnar-file-readers-in-depth-compression-transparency/columnar-file-readers-in-depth-compression-transparency.png alt="Columnar File Readers in Depth: Compression Transparency" class=related-preview-image></a><h3><a href=/blog/columnar-file-readers-in-depth-compression-transparency/>Columnar File Readers in Depth: Compression Transparency</a></h3><div class=post-meta><span class=post-author>Weston Pace</span>
<span class=post-date>April 29, 2025</span></div></article></div></div></main></div><footer class=site-footer><div class=footer-content><a href=/ class=site-title><img src=/assets/blog/logo.png alt="LanceDB Blog" class=site-logo></a><div class=footer-links><a href=https://lancedb.com/documentation class=footer-link>Documentation</a>
<a href=https://lancedb.com/pricing class=footer-link>Pricing</a>
<a href=/get-started class="footer-link get-started">Get Started</a></div></div></footer></body></html>